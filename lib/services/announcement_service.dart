import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import '../models/announcement.dart';
import '../models/announcement_reply.dart';
import '../models/session_message.dart' show MessageAttachment;
import '../models/event_message.dart' show ReplyPreview;

/// Service de gestion des annonces du club
class AnnouncementService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;

  /// Stream de toutes les annonces (temps r√©el)
  Stream<List<Announcement>> getAnnouncementsStream(String clubId) {
    return _firestore
        .collection('clubs/$clubId/announcements')
        .orderBy('created_at', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => Announcement.fromFirestore(doc))
          .toList();
    });
  }

  /// R√©cup√©rer les annonces (une seule fois)
  Future<List<Announcement>> getAnnouncements(String clubId) async {
    try {
      final snapshot = await _firestore
          .collection('clubs/$clubId/announcements')
          .orderBy('created_at', descending: true)
          .get();

      final announcements = snapshot.docs
          .map((doc) => Announcement.fromFirestore(doc))
          .toList();

      debugPrint('‚úÖ ${announcements.length} annonces charg√©es');
      return announcements;
    } catch (e) {
      debugPrint('‚ùå Erreur chargement annonces: $e');
      return [];
    }
  }

  /// Cr√©er une nouvelle annonce (admin uniquement)
  Future<void> createAnnouncement({
    required String clubId,
    required String senderId,
    required String senderName,
    required String title,
    required String message,
    required AnnouncementType type,
  }) async {
    try {
      final announcement = Announcement(
        id: '', // Auto-generated by Firestore
        title: title,
        message: message,
        senderId: senderId,
        senderName: senderName,
        type: type,
        createdAt: DateTime.now(),
      );

      await _firestore
          .collection('clubs/$clubId/announcements')
          .add(announcement.toFirestore());

      debugPrint('‚úÖ Annonce cr√©√©e: $title');
    } catch (e) {
      debugPrint('‚ùå Erreur cr√©ation annonce: $e');
      rethrow;
    }
  }

  /// Supprimer une annonce (admin uniquement)
  Future<void> deleteAnnouncement(String clubId, String announcementId) async {
    try {
      await _firestore
          .collection('clubs/$clubId/announcements')
          .doc(announcementId)
          .delete();

      debugPrint('‚úÖ Annonce supprim√©e: $announcementId');
    } catch (e) {
      debugPrint('‚ùå Erreur suppression annonce: $e');
      rethrow;
    }
  }

  /// Mettre √† jour une annonce (admin uniquement)
  Future<void> updateAnnouncement({
    required String clubId,
    required String announcementId,
    String? title,
    String? message,
    AnnouncementType? type,
  }) async {
    try {
      final updates = <String, dynamic>{};

      if (title != null) updates['title'] = title;
      if (message != null) updates['message'] = message;
      if (type != null) updates['type'] = type.name;

      if (updates.isEmpty) return;

      await _firestore
          .collection('clubs/$clubId/announcements')
          .doc(announcementId)
          .update(updates);

      debugPrint('‚úÖ Annonce mise √† jour: $announcementId');
    } catch (e) {
      debugPrint('‚ùå Erreur mise √† jour annonce: $e');
      rethrow;
    }
  }

  // ==================== READ TRACKING ====================

  /// Marquer une annonce comme lue par un utilisateur
  Future<void> markAnnouncementAsRead({
    required String clubId,
    required String announcementId,
    required String userId,
  }) async {
    try {
      await _firestore
          .collection('clubs/$clubId/announcements')
          .doc(announcementId)
          .update({
        'read_by': FieldValue.arrayUnion([userId]),
      });
      debugPrint('‚úÖ Annonce marqu√©e comme lue: $announcementId');
    } catch (e) {
      debugPrint('‚ùå Erreur marquage annonce lue: $e');
    }
  }

  /// Compter les annonces non lues
  Future<int> getUnreadCount({
    required String clubId,
    required String userId,
  }) async {
    try {
      final snapshot = await _firestore
          .collection('clubs/$clubId/announcements')
          .get();

      return snapshot.docs.where((doc) {
        final readBy =
            (doc.data()['read_by'] as List<dynamic>?)?.cast<String>() ?? [];
        return !readBy.contains(userId);
      }).length;
    } catch (e) {
      debugPrint('‚ùå Erreur comptage annonces non lues: $e');
      return 0;
    }
  }

  // ==================== REPLIES ====================

  /// Stream des r√©ponses pour une annonce
  Stream<List<AnnouncementReply>> getRepliesStream({
    required String clubId,
    required String announcementId,
  }) {
    debugPrint('üîÑ getRepliesStream called for announcement: $announcementId');
    return _firestore
        .collection('clubs/$clubId/announcements/$announcementId/replies')
        .orderBy('created_at', descending: false)
        .snapshots()
        .map((snapshot) {
      debugPrint('üì® Received ${snapshot.docs.length} replies from Firestore');
      final replies = <AnnouncementReply>[];
      for (final doc in snapshot.docs) {
        try {
          replies.add(AnnouncementReply.fromFirestore(doc));
        } catch (e) {
          debugPrint('‚ùå Error parsing reply ${doc.id}: $e');
        }
      }
      debugPrint('‚úÖ Parsed ${replies.length} replies successfully');
      return replies;
    });
  }

  /// R√©cup√©rer les r√©ponses (une seule fois)
  Future<List<AnnouncementReply>> getReplies({
    required String clubId,
    required String announcementId,
  }) async {
    try {
      final snapshot = await _firestore
          .collection('clubs/$clubId/announcements/$announcementId/replies')
          .orderBy('created_at', descending: false)
          .get();

      return snapshot.docs
          .map((doc) => AnnouncementReply.fromFirestore(doc))
          .toList();
    } catch (e) {
      debugPrint('‚ùå Erreur chargement r√©ponses: $e');
      return [];
    }
  }

  /// Envoyer une r√©ponse √† une annonce
  Future<String> sendReply({
    required String clubId,
    required String announcementId,
    required String senderId,
    required String senderName,
    required String message,
    String? replyToId,
    ReplyPreview? replyToPreview,
    List<MessageAttachment>? attachments,
  }) async {
    try {
      final reply = AnnouncementReply(
        id: '',
        senderId: senderId,
        senderName: senderName,
        message: message,
        createdAt: DateTime.now(),
        readBy: [senderId],
        replyToId: replyToId,
        replyToPreview: replyToPreview,
        attachments: attachments ?? [],
      );

      final docRef = await _firestore
          .collection('clubs/$clubId/announcements/$announcementId/replies')
          .add(reply.toFirestore());

      // Incr√©menter le compteur de r√©ponses
      await _firestore
          .collection('clubs/$clubId/announcements')
          .doc(announcementId)
          .update({
        'reply_count': FieldValue.increment(1),
      });

      debugPrint('‚úÖ R√©ponse envoy√©e pour annonce $announcementId');
      return docRef.id;
    } catch (e) {
      debugPrint('‚ùå Erreur envoi r√©ponse: $e');
      rethrow;
    }
  }

  /// Cr√©er un ReplyPreview √† partir d'une r√©ponse existante
  ReplyPreview createReplyPreview(AnnouncementReply originalReply) {
    final preview = originalReply.message.length > 50
        ? '${originalReply.message.substring(0, 50)}...'
        : originalReply.message;
    return ReplyPreview(
      senderName: originalReply.senderName,
      messagePreview: preview,
    );
  }

  /// Supprimer une r√©ponse
  Future<void> deleteReply({
    required String clubId,
    required String announcementId,
    required String replyId,
  }) async {
    try {
      await _firestore
          .collection('clubs/$clubId/announcements/$announcementId/replies')
          .doc(replyId)
          .delete();

      // D√©cr√©menter le compteur de r√©ponses
      await _firestore
          .collection('clubs/$clubId/announcements')
          .doc(announcementId)
          .update({
        'reply_count': FieldValue.increment(-1),
      });

      debugPrint('‚úÖ R√©ponse supprim√©e: $replyId');
    } catch (e) {
      debugPrint('‚ùå Erreur suppression r√©ponse: $e');
      rethrow;
    }
  }

  /// Marquer une r√©ponse comme lue
  Future<void> markReplyAsRead({
    required String clubId,
    required String announcementId,
    required String replyId,
    required String userId,
  }) async {
    try {
      await _firestore
          .collection('clubs/$clubId/announcements/$announcementId/replies')
          .doc(replyId)
          .update({
        'read_by': FieldValue.arrayUnion([userId]),
      });
    } catch (e) {
      debugPrint('‚ùå Erreur marquage r√©ponse lue: $e');
    }
  }

  // ==================== ATTACHMENTS ====================

  /// Upload une pi√®ce jointe pour une annonce
  Future<MessageAttachment> uploadAnnouncementAttachment({
    required String clubId,
    required String announcementId,
    required File file,
    required String type, // 'image' ou 'pdf'
  }) async {
    final filename = path.basename(file.path);
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final storagePath =
        'clubs/$clubId/announcements/$announcementId/attachments/${timestamp}_$filename';

    final ref = _storage.ref().child(storagePath);
    await ref.putFile(file);

    final url = await ref.getDownloadURL();
    final fileSize = await file.length();

    debugPrint('‚úÖ Pi√®ce jointe upload√©e: $filename');

    return MessageAttachment(
      type: type,
      url: url,
      filename: filename,
      size: fileSize,
    );
  }
}
