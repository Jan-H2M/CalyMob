import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import '../models/event_message.dart';

/// Service de gestion des messages liés aux événements
class EventMessageService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Stream des messages d'un événement (temps réel)
  Stream<List<EventMessage>> getEventMessagesStream(
    String clubId,
    String operationId,
  ) {
    return _firestore
        .collection('clubs/$clubId/operations/$operationId/messages')
        .orderBy('created_at', descending: false)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => EventMessage.fromFirestore(doc))
          .toList();
    });
  }

  /// Récupérer les messages d'un événement (une seule fois)
  Future<List<EventMessage>> getEventMessages(
    String clubId,
    String operationId,
  ) async {
    try {
      final snapshot = await _firestore
          .collection('clubs/$clubId/operations/$operationId/messages')
          .orderBy('created_at', descending: false)
          .get();

      final messages = snapshot.docs
          .map((doc) => EventMessage.fromFirestore(doc))
          .toList();

      debugPrint('✅ ${messages.length} messages chargés pour event $operationId');
      return messages;
    } catch (e) {
      debugPrint('❌ Erreur chargement messages: $e');
      return [];
    }
  }

  /// Envoyer un message (participant inscrit uniquement)
  Future<void> sendMessage({
    required String clubId,
    required String operationId,
    required String senderId,
    required String senderName,
    required String message,
  }) async {
    try {
      final eventMessage = EventMessage(
        id: '', // Auto-generated by Firestore
        senderId: senderId,
        senderName: senderName,
        message: message,
        createdAt: DateTime.now(),
      );

      await _firestore
          .collection('clubs/$clubId/operations/$operationId/messages')
          .add(eventMessage.toFirestore());

      debugPrint('✅ Message envoyé pour event $operationId');
    } catch (e) {
      debugPrint('❌ Erreur envoi message: $e');
      rethrow;
    }
  }

  /// Vérifier si l'utilisateur est inscrit à l'événement
  Future<bool> isUserParticipant({
    required String clubId,
    required String operationId,
    required String userId,
  }) async {
    try {
      // Query by membre_id field, not by document ID
      final snapshot = await _firestore
          .collection('clubs/$clubId/operations/$operationId/inscriptions')
          .where('membre_id', isEqualTo: userId)
          .get();

      final isParticipant = snapshot.docs.isNotEmpty;
      debugPrint(
          'User $userId ${isParticipant ? "IS" : "IS NOT"} participant for event $operationId');

      return isParticipant;
    } catch (e) {
      debugPrint('❌ Erreur vérification participant: $e');
      return false;
    }
  }

  /// Supprimer un message (auteur ou admin uniquement)
  Future<void> deleteMessage({
    required String clubId,
    required String operationId,
    required String messageId,
  }) async {
    try {
      await _firestore
          .collection('clubs/$clubId/operations/$operationId/messages')
          .doc(messageId)
          .delete();

      debugPrint('✅ Message supprimé: $messageId');
    } catch (e) {
      debugPrint('❌ Erreur suppression message: $e');
      rethrow;
    }
  }

  /// Marquer les messages comme lus par un utilisateur
  Future<void> markMessagesAsRead({
    required String clubId,
    required String operationId,
    required String userId,
  }) async {
    try {
      final snapshot = await _firestore
          .collection('clubs/$clubId/operations/$operationId/messages')
          .get();

      final batch = _firestore.batch();
      int updated = 0;

      for (final doc in snapshot.docs) {
        final readBy = (doc.data()['read_by'] as List<dynamic>?)?.cast<String>() ?? [];
        if (!readBy.contains(userId)) {
          batch.update(doc.reference, {
            'read_by': FieldValue.arrayUnion([userId]),
          });
          updated++;
        }
      }

      if (updated > 0) {
        await batch.commit();
        debugPrint('✅ $updated messages marqués comme lus par $userId');
      }
    } catch (e) {
      debugPrint('❌ Erreur marquage messages lus: $e');
    }
  }
}
